メモ

　商品登録時に在庫数のフィールドも必要では？
　というか商品テーブルに在庫数のカラム必要では？
　累計購入数は商品テーブルになくても良い気がする。
　別テーブルに企業ID,商品ID,累計購入数 の形で切り出したい。
　　→ 注文テーブルに注文数量カラムを追加して、
　　　商品テーブルにも累計購入数カラムは保持しておく。
　　　そもそも注文数量カラムは必要だし、注文数量カラムがordersに
　　　追加されたからと言って商品テーブルから累計購入数を
　　　削除していいわけではない。理由は、注文は絶え間なく増え続けるため
　　　一定期間後にデータを外部に切り出したり削除しなければならない。
　　　そのため、商品テーブルに累計購入数の情報だけ持っておけば、
　　　人気順などですぐにそこを見て計算することができる。

　JWTトークンはcookieに保存し、HttpOnlyを付加する
　　jsからは付与できないのでサーバー側で付与する必要があるとのこと。
　　SpringBootからはJWTトークンを含めたCookieの形で返す。

　トップ画面が使用する認証確認用のエンドポイントを新たに作成する
　　CookieにJWTトークンが格納されているか調べる。なければ403エラー
　　格納されていれば署名が正しいか検証する。
　　トップページから各ページに遷移する際は認証確認用のエンドポイントに接続する
　　認証確認用エンドポイントからトークンを受け取った後、ページ遷移を行う
　　その後に商品追加を行って認証が通ること

　cookieの使い方
　現在SecurityFilterChainに設定している.oauth2ResourceServer().oauth.jwt()
　を削除して、参考サイトのようにCookie用のカスタムフィルターを
　SpringSecurityに組み込む方法を使えば実装できそう。
https://www.takatechskill.com/archives/453

　/admin/token, /ecsite/token はトークンが無ければユーザ名とパスワード
　それ以外はCookieチェック
　というか、せっかくだから認可で管理システム用とECサイトシステム用で
　わければいいのでは？JWTの認可の勉強にもなるし

　各Entityクラスには共通しているカラムがあるので
　BaseEntityを定義してそれを継承する形にする。
　以下サイトでそのようにしていたので、良いなと思い参考にした。
https://qiita.com/shukawam/items/6e379df031dccebddd36

　Spring Data Jpaがデフォルトで提供するsave()メソッドについて、
　<S extends T> S save(S entity)　のような実装であるため、
　例えば、implements JpaRepository<User, Long> で実装している場合
　Userエンティティクラスを継承したクラスであればこのRepositoryクラスの
　Saveメソッドに渡すことが可能である。

　@EnableJpaAuditing, @EntityListeners(AuditingEntityListener.class)
　各テーブルのカラム(ユーザを表すテーブル以外)に作成者、更新者の情報も
　付加した方が良いと思うのでそのように実装する。
　Administrator,Customer -> id, name, createdAt, updatedAt
　Order -> id, createdAt
　それ以外 -> id, name, createdAt,updatedAt,createdBy,updatedBy
　よく考えたら注文は変更できたら困るので、ordersテーブルにupdatedAtはいらない気がする。

　customersテーブルも、ECサイトユーザの認証情報のみを保持するusersテーブルと、
　残高などを保持するcustomersテーブルとに分けた方が良いのだろうか？
　しかし、customersテーブルにECサイトを利用するユーザの情報を
　切り出したからと言って、createdByは常にそのcustomer情報に該当するuserなので、
　別に切り出さなくてもいいのではないか？

　BaseEntity,UserAuditableEntityをabstractクラスにして
　監査を有効にするアノテーションをつけてもそれを継承するクラスで
　ちゃんとcreated,updatedは機能するのだろうか？

　BaseEntity,UserAuditEntityに監査用のアノテーションをつける。
　必要なのであれば監査用のconfigクラスも作成する。
　この2つのEntityを継承したEntityクラスでも問題なく
　その時々の日時やユーザが格納される根拠を調べる。

　AuditAwareの実装参考サイト
https://www.memory-lovers.blog/entry/2018/01/10/014046
https://spring.pleiades.io/spring-data/jpa/reference/auditing.html#auditing.auditor-aware

　MapStructの実装を進めて、AdminCreateForm -> Administratorへの変換、
　Administrator -> AdminCreateResponseへの変換ができるようにする

　認証済みユーザをbyに指定する方法の参考
https://qiita.com/kunikunipon/items/291f1767edf927e672e5

　MapStructは基盤Mapperインタフェースを定義して、
　そこでspringのDI設定やコンストラクタ設定、
　異なるプロパティを無視する設定をしておき、
　各Mapperインタフェースでその基盤Mapperを指定する形がよさそう。
https://qiita.com/konkon-T/items/149cf0dc3e31a54de6be

　どうやらLocalDateTimeはカスタムコンバーターを作成しないとダメっぽい？
https://mike-neck.hatenadiary.com/entry/2014/09/11/162055
　いややっぱり大丈夫そう
https://stackoverflow.com/questions/54840769/how-to-persist-localdate-with-jpa
　なんならcolumnDefinitionつけなくてもエラーが出ない。
　「JdbcTypeRecommendationException: Could not determine recommended
　JdbcType for Java type 'com.example.ecsite.data.entity.Administrator'」
　のエラーが出る理由は、上記のカスタムコンバーターやcolumnDefinirionではなく、
　AdministratorエンティティクラスがSerializableを実装していないことだった。
　しかしなぜ他のEntityではこのエラーが出ないのか？実装を進めていったら
　他のEntityもこのエラーが出るのか？いや、監査対象のEntityクラスだから
　Serializableをつけないと、createdBy,updatedByにバインドできないということ？
　それだと納得できる。

「Failed to bind properties under 'jwt.private-key' to java.security.interfaces.ECPrivateKey:」
　のエラーが出る。秘密鍵ファイルの内容をECPrivateKeyインタフェースに変換する
　コンバーターが見つからないとのこと。てことは定義したら行けるのだろうか？
　しかし、参考サイトにそんな記述は無かったような気がするのだが。
　SecurityFilterChainでJWTを有効にしていないからだろうか？
　それなら納得できる。だが、有効化するとWWW-

　.oauth2ResourceServer( rs -> rs.jwt( jwt -> {})) 内で、
　jwt.bearerTokenResolver(BearerTokenResolver)で
　リクエストからベアラートークンを解決する方法をカスタマイズできる。
　BearerTokenResolverインタフェースのresolve()メソッドは引数に
　HttpServletRequestを受け取る。Cookieを検証するカスタムフィルターも
　引数にHttpServletRequestを受け取っているため、もしかしたら
　SpringSecurityがデフォルトで用意するJWT認証を上手くカスタマイズできるのでは？
　ただ、Authentication周りがよくわからないので、
　とりあえずCookieの参考サイトの通りに進めてみるのが良いかもしれない。

======================================================================

　商品のジャンルは商品登録の際に選択できるようにしたい。
　ということはcategoriesテーブルを新たに作成し、
　そっちから先にデータを登録して
　商品を登録する際は既にあるcategoriesテーブルのデータを選択するように
　させた方が良いのでは？

　R2はプレフィックスで階層を表現できるため、商品のジャンルごとに
　バケットを分ける必要はなく、階層で表現すればよい。
　そうすれば、データベースからgenreを取得してその文字列をそのまま
　取得したい階層に指定することができる。

　OIDCでJWTトークンを生成する場合、認証が終わった後に
　SpringBootとOIDC間でやり取りすることは可能なのか？
　それができるなら、そこで企業IDをOIDCに送信してトークン内に含められる？

　S3Configもレコードにできるのならしたい。

======================================================================

マークダウンのテーブル便利な拡張機能
https://qiita.com/tawara_/items/5d59cf725e7c7aa72f0f

springbootでは multipart/form-data で送信されたそれぞれの情報を
@RequestPart("名前")で取得することができる。
https://b1san-blog.com/post/spring/spring-file/

aws-java-sdkをそのまま依存関係に追加すると、
ライブラリ全体をインクルードするため、かなりの量の不要なファイルも
取り込むことになってしまう。
aws-java-sdkは1.9.0以降、機能ごとにライブラリを取り込みできるため
そのようにした方が良い。
https://qiita.com/s-katsumata/items/34a326f1d802add10119

@ConfigurationPropertyがつけられたクラスをSpringDIに認識させる3つの方法
@EnableConfigurationPropertiesは記述が簡単だが、
@Beanで管理すると、@Beanメソッドを定義する際にprefixを上書きすることができ、
「同じ構造の異なるprefixを持つプロパティ」を1つのクラスで読み込むことができる。
https://qiita.com/cfg17771855/items/905da3100ae99c5197f0

MySQL8.0以降でユーザに権限を与える場合、ユーザ作成と権限付与は
別々に行わなければならないらしい？
https://www.grimoire.tokyo/2022/04/14/post-252/
https://qiita.com/Atsulabo/items/7512cdc267d89307995d

新たにMYSQL_DATABASEを指定したが、データベースが作られない。
　→ MySQLのdocker公式イメージは、ボリュームが空の状態の時だけ
　　初期化スクリプトを実行し、MYSQL_DATABASE,MYSQL_USERなどを作成する。
　　そのため、ボリュームを削除して再度upしなければならない。

docker compose down は up コマンドと真逆のことをする。
つまり、up で作られうるもの(イメージ、コンテナ、ボリューム、ネットワーク)を
すべて削除する。
https://qiita.com/suin/items/19d65e191b96a0079417

javaで画像ファイルどうかはjavax.imageio.ImageIO#reqd(File)
メソッドで判定することができる。
https://blog.ricemountainer.net/posts/2017/453836237/

springbootからR2にアクセスするコードは以下参照
https://developers.cloudflare.com/r2/examples/aws/aws-sdk-java/

コントローラーのメソッドの引数にUriComponentsBuilderを受け取ることで、
簡単に相対パスのURLを作成することができる。
例えば、コントローラのパスが/controller、メソッドのパスが/abc だった場合、
builder.path("") とすると、http://localhost:8080/controller/abc
といったURLを作成することができる。
https://techorgana.com/java/java_web_flamework/spring/5266/