メモ

　JWTトークン作成の流れ
1.ヘッダとペイロードを定義する
2.ヘッダとペイロードをBASE64エンコードし.でつなげる
3.エンコードされたヘッダとペイロードを指定したアルゴリズムと秘密鍵で署名する
4.署名をBASE64エンコードする
5.署名を.でつなげる

　JWTトークン検証の流れ
1.HttpRequest.getCookie()でクッキーを取得
2.クッキーにJWT_TOKENが含まれているか確認、なければ例外
3.JWTトークンをデコードする
4.クレームのsubからユーザ名、scopeからロールを取得する
5.

　Formクラスもレコードでいいのでは？ユーザの入力をサーバ側で
　書き換えられる必要などないはずなので、できそうなら変更する

　ログインで/token/adminを指定してるはずなのに、
　Cookieが無いと403エラーが返されてしまう。
　なぜ/admin/createはCookie認証でない方のSecurityFilterChainをちゃんと指定できたのに、
　/token/adminではできなくなっているのか？
　原因は、SecurityMatcher()の説明にあった以下の文章かもしれない。
　「securityMatcher(String...) を呼び出すと、
　以前の securityMatcher(String...) (文字列)}}、
　securityMatcher(RequestMatcher) ()}、
　securityMatchers(Customizer) (文字列)}、
　および securityMatchers() (文字列)} の呼び出しがオーバーライドされます」
　/admin/createが機能して/token/adminが機能しないのは、
　先にsecurityMatcher("/token/**) を記述してしまっているから、
　後に記述したsecurityMatcher("/admin/create)によってそれが上書きされてしまい、
　/admin/createのみが有効となっている？
　securityMatchers(Customizer) を使用すれば解決できそう。
　　→ 解決できた。

　Cookieをサーバに送信できていない。
　/token/adminからのレスポンスには、ちゃんとCookieが含まれている。
　しかし、開発者ツールのApplication -> Cookiesを確認しても
　該当のCookieが保存されていない。
https://developer.mozilla.org/ja/docs/Web/HTTP/Reference/Headers/Set-Cookie
　JavaScriptのSet-Cookieに以下のようなことが書いてある。
　「フェッチ API または XMLHttpRequest API のリクエストが CORS を使用する 場合、
　ブラウザーはリクエストに資格情報がない限り、サーバーのレスポンスにある
　Set-Cookie ヘッダーを無視します。」
　これが原因だろうか？CORSを使って通信しているので無視されてしまっているのか？
　credentialsをincludeにすればよい？includeに設定しても、
　Samesite属性がStrictまたはLaxの場合はCookieはサイトをまたいで送信されないとのこと。

　「さらに、この状況ではサーバーは Access-Control-Allow-Origin
　レスポンスヘッダーでクライアントの元のサーバーを
　明示的に指定しなければなりません（つまり、* は許可されません）。」
　これも原因だろうか？
https://developer.mozilla.org/ja/docs/Web/API/Fetch_API/Using_Fetch#including_credentials

　setAllowedHeaders()はCORSリクエストを許可するヘッダ情報を指定する？
https://ti-tomo-knowledge.hatenablog.com/entry/2019/12/15/200327

「クッキーの SameSite 属性が Strict または Lax に設定されている場合、
　credentials が include に設定されていても、
　クッキーはサイトをまたいで送信されないことに注意してください。」
https://developer.mozilla.org/ja/docs/Web/API/Fetch_API/Using_Fetch#including_credentials

　SameSiteのNoneの説明文
　「ブラウザーがクロスサイトと同一サイトの両方のリクエストでクッキーを送信することを意味します。
　この値を設定する際には、 Secure 属性も設定する必要があります。
　SameSite=None; Secure のようにします。 Secure 属性がないと、次のエラーが記録されます。」
　「メモ: Secure のクッキーは、 HTTPS プロトコルで暗号化されたリクエストでのみサーバーに送られます。
　なお、安全でないサイト (http:) では、 Secure ディレクティブでクッキーを設定することができないため、
　SameSite=None を使用することができません。」

　異なるオリジン間でCookieをやり取りしたい場合、SameSiteをNoneにする
　SameSiteをNoneにする場合、Secure属性を設定しなければならない
　Secure属性を設定する場合、https同士のオリジン間による通信しか行えない。
　ということは、SpringBootもLive Serverもhttpsで行わないと
　Cookieのやり取りができないということ？
　とりあえず、両方ともhttpsに設定する方法を調べて確かめてみる

　SpringBootでhttps設定する方法と、opensslでECDSAを用いた証明書作成の参考
https://job-info.hateblo.jp/entry/2024/07/03/233602
https://christina04.hatenablog.com/entry/openssl-command
　Live Serverをhttpsにする方法の参考
https://mitikusa-engineer.com/other/visual-studio-code/vsc-live-server-https/
　両方ともhttpsにすることで、無事フロントからSpringBootに
　Cookieを送信できるようになった。

　Cookieは送信できるようになったが、JWTの検証に失敗してしまう。
　「Cannot verify JWS signature: unable to locate signature verification
　key for JWS with header: {alg=HS256}」のエラーが出る。
https://github.com/jwtk/jjwt/discussions/928
https://stackoverflow.com/questions/78836490/validate-jwt-java17-spring-security-jwt0-12-6
　verifyWith()に変更しても、同じエラーが出る。
　変わったのは、decryptWith()の時は赤字で該当エラーのみコンソールに表示されたが、
　verifyWith()にしたら白文字のスタックトレース形式で表示された。

　Sysoutで生成時と検証時のトークンを出力したが、
　トークン文字列の内容は完全に一致している。
　何がダメなのか？1つの秘密鍵で検証しようとしているのがダメなのか？
　それならなぜ引数に秘密鍵を受け取れるverifyWith()メソッドがあるのか？
　とりあえず公開鍵を作ってそれを使う形で検証してみるのがよいか？

　「This also implies that this key MUST be a valid key for
　the signature algorithm (alg header) used for the JWS.
　If there is any chance that the parser will also encounter JWEs,
　or JWSs that need different signature verification keys
　based on the JWS being parsed, it is strongly recommended to configure
　your own keyLocator instead of calling this method.」

　他にio.jsonwebtokenを使用しているコードを見てみる。
https://qiita.com/LiPing/items/5b063d45392f15fb457b
　コードはKotlinだが、signWith()のところで秘密鍵だけではなく、
　アルゴリズムも指定している。自分のコードでは秘密鍵しか指定していないため、
　アルゴリズムも指定してみる。

　なんかできた。
　原因は、getClaimFromToken()内のdecryptWith()をverifyWith()に
　修正し忘れていたことだった。signWith()の第二引数にアルゴリズムを指定しなくても、
　decryptWith()をverifyWith()に変更することで解決できた。

======================================================================

　R2はプレフィックスで階層を表現できるため、商品のジャンルごとに
　バケットを分ける必要はなく、階層で表現すればよい。
　そうすれば、データベースからgenreを取得してその文字列をそのまま
　取得したい階層に指定することができる。

　OIDCでJWTトークンを生成する場合、認証が終わった後に
　SpringBootとOIDC間でやり取りすることは可能なのか？
　それができるなら、そこで企業IDをOIDCに送信してトークン内に含められる？

　.oauth2ResourceServer( rs -> rs.jwt( jwt -> {})) 内で、
　jwt.bearerTokenResolver(BearerTokenResolver)で
　リクエストからベアラートークンを解決する方法をカスタマイズできる。
　BearerTokenResolverインタフェースのresolve()メソッドは引数に
　HttpServletRequestを受け取る。Cookieを検証するカスタムフィルターも
　引数にHttpServletRequestを受け取っているため、もしかしたら
　SpringSecurityがデフォルトで用意するJWT認証を上手くカスタマイズできるのでは？
　ただ、Authentication周りがよくわからないので、
　とりあえずCookieの参考サイトの通りに進めてみるのが良いかもしれない。

======================================================================

マークダウンのテーブル便利な拡張機能
https://qiita.com/tawara_/items/5d59cf725e7c7aa72f0f

springbootでは multipart/form-data で送信されたそれぞれの情報を
@RequestPart("名前")で取得することができる。
https://b1san-blog.com/post/spring/spring-file/

aws-java-sdkをそのまま依存関係に追加すると、
ライブラリ全体をインクルードするため、かなりの量の不要なファイルも
取り込むことになってしまう。
aws-java-sdkは1.9.0以降、機能ごとにライブラリを取り込みできるため
そのようにした方が良い。
https://qiita.com/s-katsumata/items/34a326f1d802add10119

@ConfigurationPropertyがつけられたクラスをSpringDIに認識させる3つの方法
@EnableConfigurationPropertiesは記述が簡単だが、
@Beanで管理すると、@Beanメソッドを定義する際にprefixを上書きすることができ、
「同じ構造の異なるprefixを持つプロパティ」を1つのクラスで読み込むことができる。
https://qiita.com/cfg17771855/items/905da3100ae99c5197f0

MySQL8.0以降でユーザに権限を与える場合、ユーザ作成と権限付与は
別々に行わなければならないらしい？
https://www.grimoire.tokyo/2022/04/14/post-252/
https://qiita.com/Atsulabo/items/7512cdc267d89307995d

新たにMYSQL_DATABASEを指定したが、データベースが作られない。
　→ MySQLのdocker公式イメージは、ボリュームが空の状態の時だけ
　　初期化スクリプトを実行し、MYSQL_DATABASE,MYSQL_USERなどを作成する。
　　そのため、ボリュームを削除して再度upしなければならない。

docker compose down は up コマンドと真逆のことをする。
つまり、up で作られうるもの(イメージ、コンテナ、ボリューム、ネットワーク)を
すべて削除する。
https://qiita.com/suin/items/19d65e191b96a0079417

javaで画像ファイルどうかはjavax.imageio.ImageIO#reqd(File)
メソッドで判定することができる。
https://blog.ricemountainer.net/posts/2017/453836237/

springbootからR2にアクセスするコードは以下参照
https://developers.cloudflare.com/r2/examples/aws/aws-sdk-java/

コントローラーのメソッドの引数にUriComponentsBuilderを受け取ることで、
簡単に相対パスのURLを作成することができる。
例えば、コントローラのパスが/controller、メソッドのパスが/abc だった場合、
builder.path("") とすると、http://localhost:8080/controller/abc
といったURLを作成することができる。
https://techorgana.com/java/java_web_flamework/spring/5266/

「JdbcTypeRecommendationException: Could not determine recommended
　JdbcType for Java type 'com.example.ecsite.data.entity.Administrator'」
のエラー解決は、監査ユーザに設定するAdministratorエンティティクラスが
Serializableを実装する必要があったことによるエラー。Serializableを実装して解決。
https://stackoverflow.com/questions/73312803/could-not-determine-recommended-jdbctype-for-class

Javaの標準APIではPKCS#1の鍵フォーマットは直接扱えないため、
以下のようなコマンドで、標準APIで扱えるPKCS#8に変換する必要がある。
openssl pkcs8 -in jwt.key.p1 -out jwt.key -topk8 -nocrypt
https://developer.mamezou-tech.com/blogs/2022/12/25/rsa-java-jwt/

KeyFactoryを使用しないと鍵からECPrivateKey,ECPublicKeyへの変換はできない。
https://qiita.com/rawr/items/e356f765122637df3dea