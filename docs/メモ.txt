メモ

　JWTトークンはcookieに保存し、HttpOnlyを付加する
　　jsからは付与できないのでサーバー側で付与する必要があるとのこと。
　　SpringBootからはJWTトークンを含めたCookieの形で返す。

　トップ画面が使用する認証確認用のエンドポイントを新たに作成する
　　CookieにJWTトークンが格納されているか調べる。なければ403エラー
　　格納されていれば署名が正しいか検証する。
　　トップページから各ページに遷移する際は認証確認用のエンドポイントに接続する
　　認証確認用エンドポイントからトークンを受け取った後、ページ遷移を行う
　　その後に商品追加を行って認証が通ること

　cookieの使い方
　現在SecurityFilterChainに設定している.oauth2ResourceServer().oauth.jwt()
　を削除して、参考サイトのようにCookie用のカスタムフィルターを
　SpringSecurityに組み込む方法を使えば実装できそう。
https://www.takatechskill.com/archives/453

　参考サイトと同じようにJJWTを使う形に変更しても良いかもしれない。
　APIドキュメントは以下。
https://javadoc.io/doc/io.jsonwebtoken/jjwt-api/latest/index.html

　秘密鍵生成のところで使用しているKeys.secretKeyFor()メソッドは
　どうやら現在は非推奨らしいので、例えばED25519を使用する場合は
　JWKs.CRV.Ed25519.keyPair().build()を使用するらしい。

　JJWTでscopeを設定するにはどうすればよいのだろうか？
　claim()でscope:admin のようにすればよいだろうか？

　JWTトークン作成の流れ
1.ヘッダとペイロードを定義する
2.ヘッダとペイロードをBASE64エンコードし.でつなげる
3.エンコードされたヘッダとペイロードを指定したアルゴリズムと秘密鍵で署名する
4.署名をBASE64エンコードする
5.署名を.でつなげる

　JWTトークン検証の流れ
1.HttpRequest.getCookie()でクッキーを取得
2.クッキーにJWT_TOKENが含まれているか確認、なければ例外
3.JWTトークンをデコードする
4.クレームのsubからユーザ名、scopeからロールを取得する
5.

　SpringSecurityが標準で用意してくれてるJWTの機能をなるべく使おうと思ったが、
　どうやら無理そうなので認証処理も自分で実装することにする。
https://developer.mamezou-tech.com/blogs/2022/12/10/java-jwt-auth/
https://zenn.dev/septeni_japan/articles/2025-05_spring_security

　以下サイトで「Javaの標準APIでPKCS#1の鍵フォーマットは直接扱えないため、
　最後に先ほど生成した秘密鍵を標準APIで扱えるPKCS#8[2]に変換します。」
　と記載がある。
https://developer.mamezou-tech.com/blogs/2022/12/25/rsa-java-jwt/
　なんでできているんだろうと疑問だった以下サイトを改めてみてみると、
　鍵生成のところでちゃんとそのようにしていた。
https://ik.am/entries/818
　openssl pkcs8 -topk8 -inform PEM -in private.pem -out private_key.pem -nocrypt
　つまり、プロパティファイルから鍵が読み込めなかったのは当然だったのである。
　道理で以前に行った時はできた覚えがあるのに、今回はできなかったのか。
　と思ったら変換しても無理だった。RSAだとできてECDSAだとできないとか？

　KeyFactoryを使用しないと鍵からECPrivateKey,ECPublicKeyへの変換はできない。
https://qiita.com/rawr/items/e356f765122637df3dea

　最終的に以下サイトをとりあえず真似して、後から改良できそうなところを
　改良していく形とする。
https://www.takatechskill.com/archives/453

ログインコントローラの作成から

　「Caused by: org.springframework.beans.BeanInstantiationException:
　Failed to instantiate [org.springframework.security.config.annotation.web.builders.HttpSecurity]:
　Factory method 'httpSecurity' threw exception with message:
　Found 2 beans for type interface org.springframework.security.authentication.AuthenticationManager,
　but none marked as primary」のエラーが出る。
　普通に@Primaryアノテーションを付けたら解決したが、
　なぜ@Qualifierでは解決できないのか？

　/admin/create が403エラーになってしまっている。

　前もなったかもしれないが、
　SecurityFilterChainを複数定義する時は、
　SecurityMatcher()を使用してどのエンドポイントの時に
　使われるSecurityFilterChainなのかを指定する必要がある。

　監査機能のサンプルコードが動かない。
　サンプルコードに書いてあるやり方ではStringからUserへのキャストはできないらしい。
　自分でキャストする処理を実装する必要がある。
　というか、勘違いしていたがCreatedBy,LastModifiedByに指定するのは
　認証されたユーザを表す、つまりSpringSecurityでいうところのUserクラスなので
　AdministratorではなくUserでいいのでは？

　Formクラスもレコードでいいのでは？ユーザの入力をサーバ側で
　書き換えられる必要などないはずなので、できそうなら変更する

======================================================================

　R2はプレフィックスで階層を表現できるため、商品のジャンルごとに
　バケットを分ける必要はなく、階層で表現すればよい。
　そうすれば、データベースからgenreを取得してその文字列をそのまま
　取得したい階層に指定することができる。

　OIDCでJWTトークンを生成する場合、認証が終わった後に
　SpringBootとOIDC間でやり取りすることは可能なのか？
　それができるなら、そこで企業IDをOIDCに送信してトークン内に含められる？

　.oauth2ResourceServer( rs -> rs.jwt( jwt -> {})) 内で、
　jwt.bearerTokenResolver(BearerTokenResolver)で
　リクエストからベアラートークンを解決する方法をカスタマイズできる。
　BearerTokenResolverインタフェースのresolve()メソッドは引数に
　HttpServletRequestを受け取る。Cookieを検証するカスタムフィルターも
　引数にHttpServletRequestを受け取っているため、もしかしたら
　SpringSecurityがデフォルトで用意するJWT認証を上手くカスタマイズできるのでは？
　ただ、Authentication周りがよくわからないので、
　とりあえずCookieの参考サイトの通りに進めてみるのが良いかもしれない。

======================================================================

マークダウンのテーブル便利な拡張機能
https://qiita.com/tawara_/items/5d59cf725e7c7aa72f0f

springbootでは multipart/form-data で送信されたそれぞれの情報を
@RequestPart("名前")で取得することができる。
https://b1san-blog.com/post/spring/spring-file/

aws-java-sdkをそのまま依存関係に追加すると、
ライブラリ全体をインクルードするため、かなりの量の不要なファイルも
取り込むことになってしまう。
aws-java-sdkは1.9.0以降、機能ごとにライブラリを取り込みできるため
そのようにした方が良い。
https://qiita.com/s-katsumata/items/34a326f1d802add10119

@ConfigurationPropertyがつけられたクラスをSpringDIに認識させる3つの方法
@EnableConfigurationPropertiesは記述が簡単だが、
@Beanで管理すると、@Beanメソッドを定義する際にprefixを上書きすることができ、
「同じ構造の異なるprefixを持つプロパティ」を1つのクラスで読み込むことができる。
https://qiita.com/cfg17771855/items/905da3100ae99c5197f0

MySQL8.0以降でユーザに権限を与える場合、ユーザ作成と権限付与は
別々に行わなければならないらしい？
https://www.grimoire.tokyo/2022/04/14/post-252/
https://qiita.com/Atsulabo/items/7512cdc267d89307995d

新たにMYSQL_DATABASEを指定したが、データベースが作られない。
　→ MySQLのdocker公式イメージは、ボリュームが空の状態の時だけ
　　初期化スクリプトを実行し、MYSQL_DATABASE,MYSQL_USERなどを作成する。
　　そのため、ボリュームを削除して再度upしなければならない。

docker compose down は up コマンドと真逆のことをする。
つまり、up で作られうるもの(イメージ、コンテナ、ボリューム、ネットワーク)を
すべて削除する。
https://qiita.com/suin/items/19d65e191b96a0079417

javaで画像ファイルどうかはjavax.imageio.ImageIO#reqd(File)
メソッドで判定することができる。
https://blog.ricemountainer.net/posts/2017/453836237/

springbootからR2にアクセスするコードは以下参照
https://developers.cloudflare.com/r2/examples/aws/aws-sdk-java/

コントローラーのメソッドの引数にUriComponentsBuilderを受け取ることで、
簡単に相対パスのURLを作成することができる。
例えば、コントローラのパスが/controller、メソッドのパスが/abc だった場合、
builder.path("") とすると、http://localhost:8080/controller/abc
といったURLを作成することができる。
https://techorgana.com/java/java_web_flamework/spring/5266/

「JdbcTypeRecommendationException: Could not determine recommended
　JdbcType for Java type 'com.example.ecsite.data.entity.Administrator'」
のエラー解決は、監査ユーザに設定するAdministratorエンティティクラスが
Serializableを実装する必要があったことによるエラー。Serializableを実装して解決。
https://stackoverflow.com/questions/73312803/could-not-determine-recommended-jdbctype-for-class