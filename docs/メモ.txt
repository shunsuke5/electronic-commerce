メモ

　商品登録時に在庫数のフィールドも必要では？
　というか商品テーブルに在庫数のカラム必要では？
　累計購入数は商品テーブルになくても良い気がする。
　別テーブルに企業ID,商品ID,累計購入数 の形で切り出したい。

　JWTトークンを用いた認証処理を実装するところから

　フロントのフォームactionにはフロントで遷移したいページを指定するのでは？
　ページの遷移は全てapiを通す必要があるので、
　buttonを使用してjavascriptで制御するようにする。
　javascriptでまず最初にspringbootのトークン確認用のマッピングに
　リクエストを送信し、持っていればページ遷移ができるし、
　持っていなければログインページに遷移させるようにする。

https://ik.am/entries/818
https://spring.pleiades.io/spring-security/reference/servlet/oauth2/resource-server/jwt.html
https://tech-lab.sios.jp/archives/8651

　管理システム用とECサイト用でSecurityFilterを分けたい。
　つまり、UserDetailsServiceを実装した
　CompanyDetailsServiceとEcsiteUserDetailsServiceの2つを実装したい。
　ただ、そんなことできるのか？Bean登録するから
　場合に応じてどっちのUserDetailsServiceを使い分けるみたいなことを
　実現する方法がわからない。

　まずSecurityFilterChainのパスを確認して
　SecurityMatcher()は指定したパス以下のリクエストをその内容で保護する。
　つまり、管理システムとECサイトとでトップのエンドポイントを
　/manage, /ecsite のように分ければ、
　2つのSecurityFilterChainを宣言して実現できるはず。
　そのメソッド内でAuthenticationManagerの引数に
　CompanyDetailsService service のようにすれば、意図している方の
　UserDetailsServiceクラスがDIされるはず。

　問題はトップエンドポイントの分け方だが、
　コントローラー内で複数のエンドポイントに分けることができるのだろうか？
　それは無理そうな気がする。そうすると、管理システムとECサイトで
　コントローラーを分けなければならなくなるのでは？
　商品一覧は同じような画面を使おうと思っているため、
　商品に関するcontrollerを2つ作るのは無駄なのでは？
　でもcontrollerだけならまだ大丈夫だろうか？

　フロントからspringbootへの通信について、最初は
　本来使用したいエンドポイントへアクセスするような指定を
　javascriptでして、もし401が返ってきたら
　/tokenにアクセスするようなメソッドを作成すればよい？
　まずはサインアップしてデータベースに登録できるかどうかを確かめる。
　トップ画面で/tokenにリクエストを送る？
　/tokenはトークン生成用リクエストだから、既にトークンを
　持っている場合に/tokenにリクエストを送信したらどうなるのか？

　トップ画面から商品管理、商品カテゴリ管理、企業情報変更
　などの各画面に遷移するタイミングでトークンの有無を調べたいが、
　ここはSpringBootは関与せずフロントのみで完結する範囲のため、
　どのようにトークンの有無を調べればよいのか？
　フロントページの遷移は前ページのリクエスト内容を調べることはできるのか？
　セキュリティ的にはローカルストレージにJWTトークンを保存すると、
　スクリプトからアクセスされてしまう可能性があるとのこと。
　httponly cookieならサーバーへのHTTPリクエストの際にのみトークンが送信される。
　しかしそうすると、フロント間のページ遷移でトークンを現在保持しているか
　どうかの判別がつかなくなってしまうのでは？
　コントローラーに認証用のエンドポイントを作れば解決できそうな気はする。
　それが一番よさそうではある。

　JWTトークンはcookieに保存し、HttpOnlyを付加する
　　jsからは付与できないのでサーバー側で付与する必要があるとのこと。
　　SpringBootからはJWTトークンを含めたCookieの形で返す。

　認証確認用のエンドポイントを新たに作成する
　　CookieにJWTトークンが格納されているか調べる。なければ403エラー
　　格納されていれば署名が正しいか検証する。ここで、疑問なのが、
　　現在はリクエストに対してSpringSecurityが自動でトークンを検証
　　してくれる構成になっていると思うのだが、これをカスタムにする必要がある？
　　SpringSecurityは恐らくリクエストボディにJWTトークンがあるかどうかで
　　判定をすると思うのだが、それだとCookie

　SpringSecurityを無効化するわけにはいかない。無効化すると
　エンドポイントそれぞれのメソッドの最初にカスタム認証処理を
　自分で書かなきゃいけなくなるはず。それは面倒すぎる。
　要は、本来リクエストにJWTトークンが含まれているか確認するところを、
　Cookieにトークンが含まれているかの確認に置き換えたい、だけである。

　トップページから各ページに遷移する際は認証確認用のエンドポイントに接続する
　認証確認用エンドポイントからトークンを受け取った後、ページ遷移を行う
　その後に商品追加を行って認証が通ること

　cookieの使い方
　現在SecurityFilterChainに設定している.oauth2ResourceServer().oauth.jwt()
　を削除して、参考サイトのようにCookie用のカスタムフィルターを
　SpringSecurityに組み込む方法を使えば実装できそう。
https://www.takatechskill.com/archives/453

　/admin/token, /ecsite/token はトークンが無ければユーザ名とパスワード
　それ以外はCookieチェック
　というか、せっかくだから認可で管理システム用とECサイトシステム用で
　わければいいのでは？JWTの認可の勉強にもなるし

　というか、複数企業がそれぞれのECサイトを作るみたいなの
　現在の設計だと無理では？顧客がある企業のECサイトに登録したとして、
　その企業の企業IDをどうやって引っ張ってくるのか？無理では？
　とりあえず1社の想定で実装することにする。

https://bitbucket.org/connect2id/nimbus-jose-jwt/src/master/src/main/java/com/nimbusds/
https://docs.oracle.com/javase/jp/22/docs/api/java.base/java/security/interfaces/package-summary.html

======================================================================

　商品のジャンルは商品登録の際に選択できるようにしたい。
　ということはcategoriesテーブルを新たに作成し、
　そっちから先にデータを登録して
　商品を登録する際は既にあるcategoriesテーブルのデータを選択するように
　させた方が良いのでは？

　R2はプレフィックスで階層を表現できるため、商品のジャンルごとに
　バケットを分ける必要はなく、階層で表現すればよい。
　そうすれば、データベースからgenreを取得してその文字列をそのまま
　取得したい階層に指定することができる。

　OIDCでJWTトークンを生成する場合、認証が終わった後に
　SpringBootとOIDC間でやり取りすることは可能なのか？
　それができるなら、そこで企業IDをOIDCに送信してトークン内に含められる？

　S3Configもレコードにできるのならしたい。

======================================================================

マークダウンのテーブル便利な拡張機能
https://qiita.com/tawara_/items/5d59cf725e7c7aa72f0f

springbootでは multipart/form-data で送信されたそれぞれの情報を
@RequestPart("名前")で取得することができる。
https://b1san-blog.com/post/spring/spring-file/

aws-java-sdkをそのまま依存関係に追加すると、
ライブラリ全体をインクルードするため、かなりの量の不要なファイルも
取り込むことになってしまう。
aws-java-sdkは1.9.0以降、機能ごとにライブラリを取り込みできるため
そのようにした方が良い。
https://qiita.com/s-katsumata/items/34a326f1d802add10119

@ConfigurationPropertyがつけられたクラスをSpringDIに認識させる3つの方法
@EnableConfigurationPropertiesは記述が簡単だが、
@Beanで管理すると、@Beanメソッドを定義する際にprefixを上書きすることができ、
「同じ構造の異なるprefixを持つプロパティ」を1つのクラスで読み込むことができる。
https://qiita.com/cfg17771855/items/905da3100ae99c5197f0

MySQL8.0以降でユーザに権限を与える場合、ユーザ作成と権限付与は
別々に行わなければならないらしい？
https://www.grimoire.tokyo/2022/04/14/post-252/
https://qiita.com/Atsulabo/items/7512cdc267d89307995d

新たにMYSQL_DATABASEを指定したが、データベースが作られない。
　→ MySQLのdocker公式イメージは、ボリュームが空の状態の時だけ
　　初期化スクリプトを実行し、MYSQL_DATABASE,MYSQL_USERなどを作成する。
　　そのため、ボリュームを削除して再度upしなければならない。

docker compose down は up コマンドと真逆のことをする。
つまり、up で作られうるもの(イメージ、コンテナ、ボリューム、ネットワーク)を
すべて削除する。
https://qiita.com/suin/items/19d65e191b96a0079417

javaで画像ファイルどうかはjavax.imageio.ImageIO#reqd(File)
メソッドで判定することができる。
https://blog.ricemountainer.net/posts/2017/453836237/

springbootからR2にアクセスするコードは以下参照
https://developers.cloudflare.com/r2/examples/aws/aws-sdk-java/

コントローラーのメソッドの引数にUriComponentsBuilderを受け取ることで、
簡単に相対パスのURLを作成することができる。
例えば、コントローラのパスが/controller、メソッドのパスが/abc だった場合、
builder.path("") とすると、http://localhost:8080/controller/abc
といったURLを作成することができる。
https://techorgana.com/java/java_web_flamework/spring/5266/